[{"title":"HttpClient","date":"2017-04-14T02:56:56.000Z","path":"2017/04/14/HttpClient/","text":"1. 简介HttpClient是Apache Jakarta Common下的子项目，用来提供高效的、最新的、功能丰富的支持HTTP协议的客户端编程工具包，并且它支持HTTP协议最新的版本和建议。HttpClient已经应用在很多的项目中，比如Apache Jakarta上很著名的另外两个开源项目Cactus和HTMLUnit都使用了HttpClient。 2. 使用方法使用HttpClient发送请求、接收响应很简单，一般需要如下几步即可。 创建HttpClient对象。 创建请求方法的实例，并指定请求URL。如果需要发送GET请求，创建HttpGet对象；如果需要发送POST请求，创建HttpPost对象。 如果需要发送请求参数，可调用HttpGet、HttpPost共同的setParams(HetpParams params)方法来添加请求参数；对于HttpPost对象而言，也可调用setEntity(HttpEntity entity)方法来设置请求参数。 调用HttpClient对象的execute(HttpUriRequest request)发送请求，该方法返回一个HttpResponse。 调用HttpResponse的getAllHeaders()、getHeaders(String name)等方法可获取服务器的响应头；调用HttpResponse的getEntity()方法可获取HttpEntity对象，该对象包装了服务器的响应内容。程序可通过该对象获取服务器的响应内容。 释放连接。无论执行方法是否成功，都必须释放连接 代码整体示例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import org.apache.commons.httpclient.*;import org.apache.commons.httpclient.methods.*;import org.apache.commons.httpclient.params.HttpMethodParams;import java.io.*;public class HttpClientTutorial &#123; private static String url = \"http://www.apache.org/\"; public static void main(String[] args) &#123; // 创建HttpClient对象 HttpClient client = new HttpClient(); // 创建请求方法的实例 GetMethod method = new GetMethod(url); // 请求参数 method.getParams().setParameter(HttpMethodParams.RETRY_HANDLER, new DefaultHttpMethodRetryHandler(3, false)); try &#123; // Execute the method. int statusCode = client.executeMethod(method); if (statusCode != HttpStatus.SC_OK) &#123; System.err.println(\"Method failed: \" + method.getStatusLine()); &#125; // Read the response body. byte[] responseBody = method.getResponseBody(); // Deal with the response. // Use caution: ensure correct character encoding and is not binary data System.out.println(new String(responseBody)); &#125; catch (HttpException e) &#123; System.err.println(\"Fatal protocol violation: \" + e.getMessage()); e.printStackTrace(); &#125; catch (IOException e) &#123; System.err.println(\"Fatal transport error: \" + e.getMessage()); e.printStackTrace(); &#125; finally &#123; // Release the connection. method.releaseConnection(); &#125; &#125;&#125;","tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://a8167270.github.io/blogRecord/tags/JavaWeb/"}]},{"title":"Http协议","date":"2017-04-14T02:43:19.000Z","path":"2017/04/14/Http协议/","text":"大三学习了《计算机网络》的课程，但是老师只把几层协议简单的介绍了一下，就没有深入的去学习。这么多年，一直在使用Http，在去年的时候才开始使用到Https，回过头来发现关于Http的细节性的东西遗漏了很多。欠过账的迟早要还的！在我对Servlet进行研究时，发现很多底层上的参数搞不清楚到底是协议上的还是Servlet上的。所以，还是从Http的协议开始入手，重新学习和总结一下。 Http简介HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。 HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。 HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。 HTTP默认端口号为80，Https的默认端口为443。 特点1、简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。 2、灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。 3.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 4.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 5、支持B/S及C/S模式。 TCP &amp; HTTP &amp; UDP:TCP/IP是个协议组，可分为四个层次：网络接口层、网络层、传输层和应用层。 网络层 所包含协议 网络层 IP协议、ICMP协议、ARP协议、RARP协议和BOOTP协议 传输层 TCP协议、UDP协议 应用层 有FTP、HTTP、TELNET、SMTP、DNS等协议 因此，HTTP本身就是一个协议，是从Web服务器传输超文本到本地浏览器的传送协议。 socketsocket是为了实现通信过程而建立成来的通信管道，其真实的代表是客户端和服务器端的一个通信进程，双方进程通过socket进行通信，而通信的规则采用指定的协议。 socket只是一种连接模式，不是协议，tcp、udp，简单的说（虽然不准确）是两个最基本的协议,很多其它协议都是基于这两个协议如，http就是基于tcp的，.用socket可以创建tcp连接，也可以创建udp连接，这意味着，用socket可以创建任何协议的连接，因为其它协议都是基于此的。 Http消息HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。 URL和URI区别 URI URL URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。 URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上。 Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的 采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等 URI一般由三部组成：1、访问资源的命名机制。 2、存放资源的主机名。3、资源自身的名称，由路径表示，着重强调于资源。 URL一般由三部组成：1、协议(或称为服务方式)。2、存有该资源的主机IP地址(有时也包括端口号)。3、主机资源的具体地址。如目录和文件名等 例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程： 1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址; 2、解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接; 3、浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器; 4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器; 5、释放 TCP连接; 6、浏览器将该 html 文本并显示内容; 客户端请求消息客户端发送一个HTTP请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成，下图给出了请求报文的一般格式。 Get请求1234567GET /562f25980001b1b106000338.jpg HTTP/1.1Host img.mukewang.comUser-Agent Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36Accept image/webp,image/*,*/*;q=0.8Referer http://www.imooc.com/Accept-Encoding gzip, deflate, sdchAccept-Language zh-CN,zh;q=0.8 第一部分：请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本. GET说明请求类型为GET,[/562f25980001b1b106000338.jpg]为要访问的资源，该行的最后一部分说明使用的是HTTP1.1版本。 第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息 从第二行起为请求头部，HOST将指出请求的目的地.User-Agent,服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础.该信息由你的浏览器来定义,并且在每个请求中自动发送等等 第三部分：空行，请求头部后面的空行是必须的 即使第四部分的请求数据为空，也必须有空行。 第四部分：请求数据也叫主体，可以添加任意的其他数据。 这个例子的请求数据为空。 post请求12345678POST / HTTP1.1Host:www.wrox.comUser-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)Content-Type:application/x-www-form-urlencodedContent-Length:40Connection: Keep-Alivename=Professional%20Ajax&amp;publisher=Wiley 第一部分：请求行，第一行明了是post请求，以及http1.1版本。第二部分：请求头部，第二行至第六行。第三部分：空行，第七行的空行。第四部分：请求数据，第八行。 响应消息ResponseHTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。 请求方法和状态码请求方法根据HTTP标准，HTTP请求可以使用多种请求方法。HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。 序号 方法 描述 1 GET 请求指定的页面信息，并返回实体主体。 2 HEAD 类 似于get请求，只不过返回的响应中没有具体的内容，用于获取报头 3 POST 向 指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 4 PUT 从客 户端向服务器传送的数据取代指定的文档的内容。 5 DELETE 请求服务器删除指定的页面。 6 CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 7 OPTION S 允许客户端查看服务器的性能。 8 TRACE 回显服务器收到的请求，主要用于测试或诊断。 状态码当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求。HTTP状态码的英文为HTTP Status Code。 分类 分类描述 1** 信息，服务器收到请求，需要请求者继续执行操作 2** 成功，操作被成功接收并处理 3** 重定向，需要进一步的操作以完成请求 4** 客户端错误，请求包含语法错误或无法完成请求 5** 服务器错误，服务器在处理请求的过程中发生了错误 常见的状态码1234567200 OK //客户端请求成功400 Bad Request //客户端请求有语法错误，不能被服务器所理解401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 403 Forbidden //服务器收到请求，但是拒绝提供服务404 Not Found //请求资源不存在，eg：输入了错误的URL500 Internal Server Error //服务器发生不可预期的错误503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常 HTTP content-typeContent-Type，内容类型，一般是指网页中存在的Content-Type，用于定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件，这就是经常看到一些Asp网页点击的结果却是下载到的一个文件或一张图片的原因。 HTTP 响应头信息HTTP请求头提供了关于请求，响应或者其他的发送实体的信息。 应答头 说明 Allow 服务器支持哪些请求方法（如GET、POST等）。 Content-Encoding 文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(“Accept-Encoding”)）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。 Content-Length 表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStream，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。 Content-Type 表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。 Date 当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。 Expires 应该在什么时候认为文档已经过期，从而不再缓存它？ Last-Modified 文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。 Location 表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。 Refresh 表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(“Refresh”, “5; URL=http://host/path&quot;)让浏览器读取指定的页面。 Server 服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。 Set-Cookie 设置和页面关联的Cookie。Servlet不应使用response.setHeader(“Set-Cookie”, …)，而是应使用HttpServletResponse提供的专用方法addCookie。参见下文有关Cookie设置的讨论。 WWW-Authenticate 客户应该在Authorization头中提供什么类型的授权信息？在包含401（Unauthorized）状态行的应答中这个头是必需的。例如，response.setHeader(“WWW-Authenticate”, “BASIC realm=＼”executives＼””)。 补充get和post区别 GET在浏览器回退时是无害的，而POST会再次提交请求。 GET产生的URL地址可以被Bookmark，而POST不可以。 GET请求会被浏览器主动cache，而POST不会，除非手动设置。 GET请求只能进行url编码，而POST支持多种编码方式。 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 GET请求在URL中传送的参数是有长度限制的，而POST么有。 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。 GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。 GET参数通过URL传递，POST放在Request body中。 GET和POST还有一个重大区别： GET产生一个TCP数据包；POST产生两个TCP数据包。 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。 因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑！跳入需谨慎。为什么？ GET与POST都有自己的语义，不能随便混用。 据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。 并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。 HttpsHTTPS（全称：Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容请看SSL。 不使用SSL/TLS的HTTP通信，就是不加密的通信。所有信息明文传播，带来了三大风险。 （1） 窃听风险（eavesdropping）：第三方可以获知通信内容。（2） 篡改风险（tampering）：第三方可以修改通信内容。（3） 冒充风险（pretending）：第三方可以冒充他人身份参与通信。 SSL/TLS协议是为了解决这三大风险而设计的，希望达到： （1） 所有信息都是加密传播，第三方无法窃听。（2） 具有校验机制，一旦被篡改，通信双方会立刻发现。（3） 配备身份证书，防止身份被冒充。 参考文章1、HTTP 协议入门2、HTTP 教程3、看完还不懂HTTPS我直播吃翔","tags":[{"name":"协议","slug":"协议","permalink":"https://a8167270.github.io/blogRecord/tags/协议/"}]},{"title":"Servlet","date":"2017-04-13T07:33:26.000Z","path":"2017/04/13/Servlet与JSP/","text":"在某种程度上来讲，可以将servlet看作是含有HTML的Java程序；将JSP看作是含有Java代码的HTML页面。JSP文档可以理解成是编写servlet的另一种形式，JSP页面会被翻译成servelt，而servlet会被编译。在整个请求期间运行的就是servlet。 Servlet简介Servlet的生命周期服务器只对每一个servlet创建单一实例，每个用户请求会创建新的线程，将用户请求交付给相应的doGet和doPost进行处理。 Servlet 生命周期：Servlet 加载—&gt;实例化—&gt;服务—&gt;销毁。 init（）：在Servlet的生命周期中，仅执行一次init()方法。它是在服务器装入Servlet时执行的，负责初始化Servlet对象。可以配置服务器，以在启动服务器或客户机首次访问Servlet时装入Servlet。无论有多少客户机访问Servlet，都不会重复执行init（）。 service（）：它是Servlet的核心，负责响应客户的请求。每当一个客户请求一个HttpServlet对象，该对象的Service()方法就要调用，而且传递给这个方法一个“请求”（ServletRequest）对象和一个“响应”（ServletResponse）对象作为参数。在HttpServlet中已存在Service()方法。默认的服务功能是调用与HTTP请求的方法相应的do功能。 destroy（）： 仅执行一次，在服务器端停止且卸载Servlet时执行该方法。当Servlet对象退出生命周期时，负责释放占用的资源。一个Servlet在运行service()方法时可能会产生其他的线程，因此需要确认在调用destroy()方法时，这些线程已经终止或完成。 Servlet架构图如下： Servlet的工作流程 Web Client 向Servlet容器（Tomcat）发出Http请求 Servlet容器接收Web Client的请求 Servlet容器创建一个HttpRequest对象，将Web Client请求的信息封装到这个对象中。 Servlet容器创建一个HttpResponse对象 Servlet容器调用HttpServlet对象的service方法，把HttpRequest对象与HttpResponse对象作为参数传给 HttpServlet 对象。 HttpServlet调用HttpRequest对象的有关方法，获取Http请求信息。 HttpServlet调用HttpResponse对象的有关方法，生成响应数据。 Servlet容器把HttpServlet的响应结果传给Web Client。 Servlet的创建 Servlet容器启动时：读取web.xml配置文件中的信息，构造指定的Servlet对象，创建ServletConfig对象，同时将ServletConfig对象作为参数来调用Servlet对象的init方法。 在Servlet容器启动后：客户首次向Servlet发出请求，Servlet容器会判断内存中是否存在指定的Servlet对象，如果没有则创建它，然后根据客户的请求创建HttpRequest、HttpResponse对象，从而调用Servlet对象的service方法。 Servlet Servlet容器在启动时自动创建Servlet，这是由在web.xml文件中为Servlet设置的属性决定的。从中我们也能看到同一个类型的Servlet对象在Servlet容器中以单例的形式存在。 Servlet的配置映射配置web.xml配置1234567891011&lt;servlet&gt; &lt;servlet-name&gt;HelloWorld&lt;/servlet-name&gt; &lt;servlet-class&gt;jp.co.xiehl.servlet.ch7.HelloWorldServlet&lt;/servlet-class&gt;&lt;/servlet&gt;//servlet映射配置&lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloWorld&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;访问时：localhost:8080/工程名/hello即可。 servlet3.0 注解12@WebServlet(name=”Hello”, urlPatterns=&#123;“/hello.view”&#125;, loadOnStartup=1)public class HelloServlet extends HttpServlet &#123;&#125; 上面的例子表示为，name为Hello的servlet，url为hello.view的。 过滤器Servlet过滤器可以动态的拦截请求和响应，可以实现以下目的： 在客户端请求访问后端资源之前，拦截请求 在服务端的响应发送客户端之前，处理响应 过滤器接口过滤器是实现javax.servlet.Filter接口的类。接口包含以下三个方法： 过滤器示例：123456789101112131415161718192021222324//导入必需的 java 库import javax.servlet.*;import java.util.*;//实现 Filter 类public class LogFilter implements Filter &#123; public void init(FilterConfig config) throws ServletException &#123; // 获取初始化参数 String site = config.getInitParameter(\"Site\"); // 输出初始化参数 System.out.println(\"网站名称: \" + site); &#125; public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)&#123; // 输出站点名称 System.out.println(\"站点网址：http://www.runoob.com\"); // 把请求传回过滤链 chain.doFilter(request,response); &#125; public void destroy( )&#123; /* 在 Filter 实例被 Web 容器从服务移除之前调用 */ &#125;&#125; 过滤器实现12345678&lt;filter&gt; &lt;filter-name&gt;LoginFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.runoob.test.LogFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;Site&lt;/param-name&gt; &lt;param-value&gt;菜鸟教程&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt; 2. 状态代码Web服务器对请求的响应，一般有一个状态行、一些响应报头、一个空行和相应的文档构成；Http响应的状态行由HTTP版本、一个状态代码和一段相关的消息组成。但是消息直接与状态代码相关，而http的版本是由服务器来决定的，故而，servlet需要做的只是设置状态代码。系统自动设置的代码为200。如果需要设置状态代码，则可以使用response.setStatus,response.sendRedirect或response.sendError方法。 设置状态代码：setStatus 在向客户程序发送任何文档内容之前设置状态代码 setStatus方法以一个整数（状态代码，int类型）为参数，但为了避免出错，尽量不要使用数字，而要使用HttpServletResponse中定义的常量。每个常量的名字都来自于每个常量所对应的标准HTTP1.1消息，全部大写并添加SC（Status Code）前缀，状态代码404对应的消息为Not Found，与之对应的常量是SC_NOT_FOUND。 Http1.1中可用的特定的状态代码，如下 代码区间 描述 100-199 都是信息性的，标示客户应该采取的其他动作 200-299 标示请求成功 300-399 用于已移走的文件，常常包括Location报头，指出新的地址 400-499 表明由客户引发的错误 500-599 表示由服务器引发的错误 Http相应报头指定报头，最常用的方式是使用HttpServletResponse的setHeader方法，这个方法接收两个字符串：报头的名称和报头的值。和设置状态代码一样，必须在返回实际的文档之前指定相关报头。 1setHeader（String headerName,String headerValue） Http允许相同的报头名多次出现，例如，多个Accept和Set-Cookie报头分别指定所支持的不同MIME类型和不同cookie。","tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://a8167270.github.io/blogRecord/tags/JavaWeb/"}]},{"title":"我对代码的理解","date":"2017-04-13T01:07:51.000Z","path":"2017/04/13/我对代码的理解/","text":"转眼已经毕业快两年，从本科刚开始学C语言，到现在Java，object-c语言开发，中间接触过C#，python，jsp，jQuery，JavaScript，scala，C++，html，css，markdown等多种语言。在读研究生的时候，去日本的一家公司实习时，见识过规范的开发模式和优秀的架构，也在实验室的两年里维护了一堆漏洞百出的代码。学习过《clean code》和《重构》等关于代码质量的书，也阅读过阿里和谷歌的代码规范。阅读优秀的代码是一种享受，阅读烂代码是一种折磨。所以我想谈一谈自己对优秀的代码的一点理解。 美观代码整体外观应该是赏心悦目的。 打开编辑器，代码整体布局结构给人第一印象应该是赏心悦目的。这里的赏心悦目具体表现在代码行长度，空格，函数块的行数，及规范化的代码注释等。这些条件都处理好了，不论是什么语言，给人的感觉都应该是整齐，规范。现在编辑工具大都支持自动规范代码的功能，比如Visual studio和eclipse等，但是有的时候自动规范的代码并不一定美观，还需要自己去处理。 易读阅读代码，不看注释就能理解。 代码的易读性是代码的首要条件。代码就像是写文章，是给其他人看的。易读性的代码具体体现在函数的命名，参数的设置，函数命名可以加长，但是参数不易过多。Objective-C语言是个很好的例子，代码如下示意： 123//根据姓名和性别创建一个人- (void)createPerson:(NSString *) name withSex:(NSString *)sex; 读这种代码像读阅读文章一样，很清晰的能够明白当前的函数块要做的什么事。 简洁代码体验的是一个人的解决方案，应该最直接，效率最高！ 代码的简洁性是最体验程序员内功的地方，包括对所用语言的理解，框架API的使用及算法的设计等等。现在很多面向对象语言都开始引入函数式编程思想，C#在3.5的时候好像就已经引入linq查询，java在java8的版本引入stream，了解这些特性能够简化代码的编写。但是最重要的还是编程思维的问题，见过很多次类似if(true) return true; else return false的代码，像这种情况就很无语了。 健壮代码是能接受考验的！ 安全的代码，是在运行的过程中不会出现内存泄漏，崩溃，抛出非预见性异常等情况的。保证健壮性的代码的形式有很多种，最常见也最有效的就是添加单元测试，虽然会额外的增加工作量，但是收益还是挺大。另外一种也可以采取同行评审，但是在同时间大量代码的情况下，这种审核的效果不是很好。所以，最好在开发的过程中就要安全性保护的概念。 在编写函数块的时候： 要对入参进行判断； 在调用其他函数的时候，要明确该函数可能返回的数据； 要对可能出现的异常进行处理，可以catch，可以抛出； 明确返回值能否传回null。…… 写出健壮的代码的措施有很多，很多时候出现bug就是因为考虑不够细致，没有处理全面。 设计在工作的过程中，很多人都是一接到任务就动手开始写，花费大量的时间写完后，发现有很多地方明明可以做的更好，但是由于deadline的原因，只好不了了之，日积月累就成了破窗。所以，在接到新的任务或需求的时候，可以留一点时间进行一下规划设计： 画一下uml类图，研究一下类与类之间的关系，简单的设计一下数据模型。 根据当前的数据模型，采用何时的数据结构。 简单的画一下流程图，可以让同事帮忙看一下是否有遗漏 判断一下当前的需求符合某种模型，是否有何时设计模式可以采用 研究某一块的逻辑处理，是否有适用的成熟算法 “磨刀不误砍柴工”，做规划设计并不会耽误太多时间，但是，会让你对整个流程非常清晰， 总结好的代码并不是一蹴而就的，往往称为最佳实践的代码是经过多次评审、重构，不断的进行改善优化，才能成为优秀的代码。写代码容易，写出好代码难。写代码不是简单的码代码块，需要有敬畏之心，知道自己的代码会有改进的地方，才能不断的去学习，进步。","tags":[{"name":"代码","slug":"代码","permalink":"https://a8167270.github.io/blogRecord/tags/代码/"}]},{"title":"写在前面的话","date":"2017-04-12T06:19:11.000Z","path":"2017/04/12/写在前面的话/","text":"在读研究生的时候，看到师兄学习《算法导论》，读书笔记记录了厚厚的一本，深受感染，所以很多时候就把学习笔记记录到纸质的笔记本上，两年下来也有一两个小本。研究生毕业后，几经周折，终于在路上给搞丢了，心疼的一塌糊涂。 参加工作后，又重新开始买了一个大本记录笔记，但是问题还是出现了，在学校的时候还不明显，工作了笔记本不能随身携带，查阅很不方便。于是开始折腾blog！ csdn，博客园，简书，SegmentFault都尝试过，最终的解决方案是，作业部落VIP版 + SegmentFault。前两天回看SegmentFault的文章，感觉样式好丑，并且担心图片数据丢失问题，所以就开始想自己建一个blog。于是就使用github + hexo搭建一个静态blog。 第一个感觉就是方便，私密。之前在其他地方的blog，会慢慢地转移到这个上面来。","tags":[{"name":"生活","slug":"生活","permalink":"https://a8167270.github.io/blogRecord/tags/生活/"}]}]